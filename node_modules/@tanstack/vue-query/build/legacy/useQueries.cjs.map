{"version":3,"sources":["../../src/useQueries.ts"],"sourcesContent":["import { QueriesObserver } from '@tanstack/query-core'\nimport {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  readonly,\n  shallowReadonly,\n  shallowRef,\n  unref,\n  watch,\n} from 'vue-demi'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  DefaultError,\n  DefinedQueryObserverResult,\n  QueriesObserverOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './useQuery'\nimport type { QueryClient } from './queryClient'\nimport type { DeepUnwrapRef, MaybeRefDeep, ShallowOption } from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function does not have a parameter\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: if UseQueryOptions are already being sent through, then just return T\n  T extends UseQueryOptions\n    ? DeepUnwrapRef<T>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n      T extends {\n          queryFnData: infer TQueryFnData\n          error?: infer TError\n          data: infer TData\n        }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n      : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n        : T extends { data: infer TData; error?: infer TError }\n          ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n          : // Part 3: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n            T extends [infer TQueryFnData, infer TError, infer TData]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n            : T extends [infer TQueryFnData, infer TError]\n              ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n              : T extends [infer TQueryFnData]\n                ? UseQueryOptionsForUseQueries<TQueryFnData>\n                : // Part 4: responsible for inferring and enforcing type if no explicit parameter was provided\n                  T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                        | SkipTokenForUseQueries\n                      select?: (data: any) => infer TData\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryOptionsForUseQueries<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError,\n                      unknown extends TData ? TQueryFnData : TData,\n                      TQueryKey\n                    >\n                  : T extends {\n                        queryFn?:\n                          | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                          | SkipTokenForUseQueries\n                        throwOnError?: ThrowOnError<any, infer TError, any, any>\n                      }\n                    ? UseQueryOptionsForUseQueries<\n                        TQueryFnData,\n                        TError,\n                        TQueryFnData,\n                        TQueryKey\n                      >\n                    : // Fallback\n                      UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedQueryObserverResult rather than QueryObserverResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? QueryObserverResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedQueryObserverResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? QueryObserverResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedQueryObserverResult<TData, TError>\n            : QueryObserverResult<TData, TError>\n        : QueryObserverResult<TData, TError>\n  : QueryObserverResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: if using UseQueryOptions then the types are already set\n  T extends UseQueryOptions<\n    infer TQueryFnData,\n    infer TError,\n    infer TData,\n    any,\n    any\n  >\n    ? GetDefinedOrUndefinedQueryResult<\n        T,\n        undefined extends TData ? TQueryFnData : TData,\n        unknown extends TError ? DefaultError : TError\n      >\n    : // Part 2: responsible for mapping explicit type parameter to function result, if object\n      T extends { queryFnData: any; error?: infer TError; data: infer TData }\n      ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n      : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n        : T extends { data: infer TData; error?: infer TError }\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : // Part 3: responsible for mapping explicit type parameter to function result, if tuple\n            T extends [any, infer TError, infer TData]\n            ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n            : T extends [infer TQueryFnData, infer TError]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n              : T extends [infer TQueryFnData]\n                ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n                : // Part 4: responsible for mapping inferred type to results, if no explicit parameter was provided\n                  T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, any>\n                        | SkipTokenForUseQueries\n                      select?: (data: any) => infer TData\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? GetDefinedOrUndefinedQueryResult<\n                      T,\n                      unknown extends TData ? TQueryFnData : TData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : T extends {\n                        queryFn?:\n                          | QueryFunction<infer TQueryFnData, any>\n                          | SkipTokenForUseQueries\n                        throwOnError?: ThrowOnError<any, infer TError, any, any>\n                      }\n                    ? GetDefinedOrUndefinedQueryResult<\n                        T,\n                        TQueryFnData,\n                        unknown extends TError ? DefaultError : TError\n                      >\n                    : // Fallback\n                      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? UseQueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<QueryObserverResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? UseQueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\ntype UseQueriesOptionsArg<T extends Array<any>> = readonly [\n  ...UseQueriesOptions<T>,\n]\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = UseQueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: ShallowOption & {\n    queries:\n      | MaybeRefDeep<UseQueriesOptionsArg<T>>\n      | MaybeRefDeep<\n          readonly [\n            ...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> },\n          ]\n        >\n    combine?: (result: UseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): Readonly<Ref<TCombinedResult>> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const defaultedQueries = computed(() => {\n    // Only unref the top level array.\n    const queriesRaw = unref(queries) as ReadonlyArray<any>\n\n    // Unref the rest for each element in the top level array.\n    return queriesRaw.map((queryOptions) => {\n      const clonedOptions = cloneDeepUnref(queryOptions)\n\n      if (typeof clonedOptions.enabled === 'function') {\n        clonedOptions.enabled = queryOptions.enabled()\n      }\n\n      const defaulted = client.defaultQueryOptions(clonedOptions)\n      defaulted._optimisticResults = client.isRestoring?.value\n        ? 'isRestoring'\n        : 'optimistic'\n\n      return defaulted\n    })\n  })\n\n  const observer = new QueriesObserver<TCombinedResult>(\n    client,\n    defaultedQueries.value,\n    options as QueriesObserverOptions<TCombinedResult>,\n  )\n\n  const getOptimisticResult = () => {\n    const [results, getCombinedResult] = observer.getOptimisticResult(\n      defaultedQueries.value,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n    return getCombinedResult(\n      results.map((result, index) => {\n        return {\n          ...result,\n          refetch: async (...args: Array<any>) => {\n            const [{ [index]: query }] = observer.getOptimisticResult(\n              defaultedQueries.value,\n              (options as QueriesObserverOptions<TCombinedResult>).combine,\n            )\n\n            return query!.refetch(...args)\n          },\n        }\n      }),\n    )\n  }\n\n  const state = shallowRef(getOptimisticResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  if (client.isRestoring) {\n    watch(\n      client.isRestoring,\n      (isRestoring) => {\n        if (!isRestoring) {\n          unsubscribe()\n          unsubscribe = observer.subscribe(() => {\n            state.value = getOptimisticResult()\n          })\n\n          state.value = getOptimisticResult()\n        }\n      },\n      { immediate: true },\n    )\n  }\n\n  watch(defaultedQueries, (queriesValue) => {\n    observer.setQueries(\n      queriesValue,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n    state.value = getOptimisticResult()\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return options.shallow\n    ? shallowReadonly(state)\n    : (readonly(state) as Readonly<Ref<TCombinedResult>>)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAAgC;AAChC,sBASO;AAEP,4BAA+B;AAC/B,mBAA+B;AA4NxB,SAAS,WAId;AAAA,EACE;AAAA,EACA,GAAG;AACL,GAUA,aACgC;AAChC,MAAI,QAAQ,IAAI,aAAa,eAAe;AAC1C,QAAI,KAAC,iCAAgB,GAAG;AACtB,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,mBAAe,sCAAe;AAE7C,QAAM,uBAAmB,0BAAS,MAAM;AAEtC,UAAM,iBAAa,uBAAM,OAAO;AAGhC,WAAO,WAAW,IAAI,CAAC,iBAAiB;AA3Q5C;AA4QM,YAAM,oBAAgB,6BAAe,YAAY;AAEjD,UAAI,OAAO,cAAc,YAAY,YAAY;AAC/C,sBAAc,UAAU,aAAa,QAAQ;AAAA,MAC/C;AAEA,YAAM,YAAY,OAAO,oBAAoB,aAAa;AAC1D,gBAAU,uBAAqB,YAAO,gBAAP,mBAAoB,SAC/C,gBACA;AAEJ,aAAO;AAAA,IACT,CAAC;AAAA,EACH,CAAC;AAED,QAAM,WAAW,IAAI;AAAA,IACnB;AAAA,IACA,iBAAiB;AAAA,IACjB;AAAA,EACF;AAEA,QAAM,sBAAsB,MAAM;AAChC,UAAM,CAAC,SAAS,iBAAiB,IAAI,SAAS;AAAA,MAC5C,iBAAiB;AAAA,MAChB,QAAoD;AAAA,IACvD;AAEA,WAAO;AAAA,MACL,QAAQ,IAAI,CAAC,QAAQ,UAAU;AAC7B,eAAO;AAAA,UACL,GAAG;AAAA,UACH,SAAS,UAAU,SAAqB;AACtC,kBAAM,CAAC,EAAE,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,SAAS;AAAA,cACpC,iBAAiB;AAAA,cAChB,QAAoD;AAAA,YACvD;AAEA,mBAAO,MAAO,QAAQ,GAAG,IAAI;AAAA,UAC/B;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,YAAQ,4BAAW,oBAAoB,CAAC;AAE9C,MAAI,cAAc,MAAM;AAAA,EAExB;AAEA,MAAI,OAAO,aAAa;AACtB;AAAA,MACE,OAAO;AAAA,MACP,CAAC,gBAAgB;AACf,YAAI,CAAC,aAAa;AAChB,sBAAY;AACZ,wBAAc,SAAS,UAAU,MAAM;AACrC,kBAAM,QAAQ,oBAAoB;AAAA,UACpC,CAAC;AAED,gBAAM,QAAQ,oBAAoB;AAAA,QACpC;AAAA,MACF;AAAA,MACA,EAAE,WAAW,KAAK;AAAA,IACpB;AAAA,EACF;AAEA,6BAAM,kBAAkB,CAAC,iBAAiB;AACxC,aAAS;AAAA,MACP;AAAA,MACA;AAAA,IACF;AACA,UAAM,QAAQ,oBAAoB;AAAA,EACpC,CAAC;AAED,sCAAe,MAAM;AACnB,gBAAY;AAAA,EACd,CAAC;AAED,SAAO,QAAQ,cACX,iCAAgB,KAAK,QACpB,0BAAS,KAAK;AACrB;","names":[]}