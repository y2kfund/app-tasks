{"version":3,"file":"SplitterTransform.js","sourceRoot":"","sources":["../src/SplitterTransform.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,yDAAqF;AAerF;;;;;;;;;;;GAWG;AACH,MAAa,iBAAkB,SAAQ,mCAAgB;IAGrD,YAAmB,OAAkC;QACnD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;IACrD,CAAC;IAED,IAAW,YAAY;QACrB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAED;;;;OAIG;IACI,cAAc,CAAC,WAA6B;QACjD,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IACtC,CAAC;IAED;;;;;;;;OAQG;IACI,iBAAiB,CAAC,WAA6B,EAAE,QAAiB,IAAI;QAC3E,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC;YAC3C,IAAI,KAAK,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC;gBAC3C,WAAW,CAAC,KAAK,EAAE,CAAC;YACtB,CAAC;YACD,OAAO,IAAI,CAAC;QACd,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAES,YAAY,CAAC,KAAqB;QAC1C,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YAC7C,WAAW,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAChC,CAAC;IACH,CAAC;IAES,OAAO;QACf,MAAM,MAAM,GAAY,EAAE,CAAC;QAE3B,2FAA2F;QAC3F,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YAC7C,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC;gBAClC,IAAI,CAAC;oBACH,WAAW,CAAC,KAAK,EAAE,CAAC;gBACtB,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,MAAM,CAAC,IAAI,CAAC,KAAc,CAAC,CAAC;gBAC9B,CAAC;YACH,CAAC;QACH,CAAC;QAED,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;QAE3B,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACtB,MAAM,MAAM,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;CACF;AAlED,8CAkEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { TerminalWritable, type ITerminalWritableOptions } from './TerminalWritable';\nimport type { ITerminalChunk } from './ITerminalChunk';\n\n/**\n * Constructor options for {@link SplitterTransform}.\n *\n * @public\n */\nexport interface ISplitterTransformOptions extends ITerminalWritableOptions {\n  /**\n   * Each input chunk will be passed to each destination in the iterable.\n   */\n  destinations: Iterable<TerminalWritable>;\n}\n\n/**\n * Use this instead of {@link TerminalTransform} if you need to output `ITerminalChunk`\n * data to more than one destination.\n *\n * @remarks\n *\n * Splitting streams complicates the pipeline topology and can make debugging more difficult.\n * For this reason, it is modeled as an explicit `SplitterTransform` node, rather than\n * as a built-in feature of `TerminalTransform`.\n *\n * @public\n */\nexport class SplitterTransform extends TerminalWritable {\n  private readonly _destinations: Set<TerminalWritable>;\n\n  public constructor(options: ISplitterTransformOptions) {\n    super();\n    this._destinations = new Set(options.destinations);\n  }\n\n  public get destinations(): ReadonlySet<TerminalWritable> {\n    return this._destinations;\n  }\n\n  /**\n   * Adds a destination to the set of destinations. Duplicates are ignored.\n   * Only new chunks received after the destination is added will be sent to it.\n   * @param destination - The destination to add.\n   */\n  public addDestination(destination: TerminalWritable): void {\n    this._destinations.add(destination);\n  }\n\n  /**\n   * Removes a destination from the set of destinations. It will no longer receive chunks, and will be closed, unless\n   * `destination.preventAutoclose` is set to `true`.\n   * @param destination - The destination to remove.\n   * @param close - If `true` (default), the destination will be closed when removed, unless `destination.preventAutoclose` is set to `true`.\n   * @returns `true` if the destination was removed, `false` if it was not found.\n   * @remarks\n   * If the destination is not found, it will not be closed.\n   */\n  public removeDestination(destination: TerminalWritable, close: boolean = true): boolean {\n    if (this._destinations.delete(destination)) {\n      if (close && !destination.preventAutoclose) {\n        destination.close();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  protected onWriteChunk(chunk: ITerminalChunk): void {\n    for (const destination of this._destinations) {\n      destination.writeChunk(chunk);\n    }\n  }\n\n  protected onClose(): void {\n    const errors: Error[] = [];\n\n    // If an exception is thrown, try to ensure that the other destinations get closed properly\n    for (const destination of this._destinations) {\n      if (!destination.preventAutoclose) {\n        try {\n          destination.close();\n        } catch (error) {\n          errors.push(error as Error);\n        }\n      }\n    }\n\n    this._destinations.clear();\n\n    if (errors.length > 0) {\n      throw errors[0];\n    }\n  }\n}\n"]}